## 坐标系

#### 右手坐标系
右手坐标系在我们以前初中高中学几何的时候也经常用到。要标注X、Y和Z轴的正轴方向，就将右手背对着屏幕放置，拇指即指向X轴的正方向。伸出食指和中指，如图所示
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ff5c37f9d2a5ef3ddc37blODmGRLE03"></div>
如何确定正旋转方向：确定一个旋转轴后，右手握住拳头，拇指指向旋转轴的正方向，四指弯曲的方向为旋转的正方向。相应地，左手坐标系就用左手来判定。确定了旋转的正方向后，在公式计算中就很容易知道是该使用正角度还是负角度了。
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ff6437f9d2a27c0cdf96cMx9iOe7g03"></div>

#### 左手坐标系
伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上。其余的手指指向前方。这样就建立了一个左手坐标系。拇指、食指和其余手指分别代表x，y，z轴的正方向。
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ff62ba7f25266c46d6515xl5AFzSo03"></div>

#### 左手坐标系vs右手坐标系
两坐标系的x轴和y轴正方向保持一致，z轴正方向相反。在计算机中通常使用的是左手坐标系，而数学中则通常使用右手坐标系。计算机里面其实很多也有用右手坐标系，这个只是根据实际应用不同。

#### 标准化设备坐标
我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)，也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见

####  过渡坐标系
将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是类似于流水线分步进行的，在流水线中，物体的顶点还会被变换到多个过渡坐标系(Intermediate Coordinate System)，在这些特定的坐标系统中，一些操作或运算更加方便和容易
对我们来说比较重要的总共有5个不同的坐标系统：

*  局部空间(Local Space，或者称为物体空间(Object Space))，相对于物体自身位置的坐标空间
*  世界空间(World Space)，相对于整个（游戏）世界的坐标
*  观察空间(View Space，或者称为视觉空间(Eye Space))，以摄像机为坐标原点，摄像机的朝向为Z轴方向的坐标系
*  裁剪空间(Clip Space)，裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上
*  屏幕空间(Screen Space)，将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。

为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束

<div align = "center"><img src="http://cc.fp.ps.netease.com/file/60700d7196dee42c1db332beG1MQUTxT03"></div>

##
##
## 模型
一个三维模型是由一组三角形网格（通常为三维）组成，这些三角形通过公共边或角连接起来。
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ff9842786fd492ca7da59K4UZOTDf03"></div>
一个三维模型是由顶点数据、三角形索引和纹理组成的。

#### 顶点数据
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ff9fa143cfa70fdfd187115iD1V9b03"></div>
图中的每一个圈画出来的都是一个顶点，那么一个立方体就有8个顶点，这样的一个顶点的集合，我们就称为顶点数据的集合。

#### 三角形索引
每一个三维模型，都会三角形索引。数学里面有一个定理：不共线的三点确定惟一一个平面。三个不共线的点可以构成一个平面，这个平面就是一个三角形。现在我们约定，下图中这个立方体的3个顶点：

<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ffb2e2786fd1a3ebf4366Cas6dKB603"></div>
在三角形索引中值得注意的是，遍历点的顺序。刚才我们的排列顺序是1、2、3.根据右手定则，我们的大拇指是指向我们的眼睛。如果是3、2、1的顺序，我们的大拇指是指向屏幕的。当大拇指指向我们的眼睛时，我们时可以看到这个平面的，否则就看不到了。所以一个平面要看到正反面的话，需要有两组三角形索引。但是有的三维引擎支持设置纹理的属性，可以设置成两面可见。
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ffbde7f9d2a2d6ac5a2d5RTt7XFKb03"></div>
已知，三角形有3个顶点，所以每3个为一组，构造一个三角形。矩形由两个三角形产生，可以如图划分，也可以垂直于黄线那么，我们规定按顺时针方向构造（注意，要么全顺时针，要么全逆时针）
得到 0,3,4,0,4,1,1,4,5,1,5,2

#### 纹理
（1）纹理贴图首先，我们先来理解一下什么是贴图，贴图就是贴在一个平面上的图片或者颜色。就好像一面墙，我们会给它刷上一个颜色，或者贴上不同的墙纸一样。就像上面的立方体一样，灰色的区域就是贴图的部分。贴图也可以称为材质，有点像我们平时生活中一个物体的材质。材质具有漫反射（diffuse），镜面（specular ）或放射（emmisive ）几种类型，不同的三维引擎会有不同的支持。

（2）纹理坐标纹理坐标的主要作用是用来描述贴图应该是怎么贴的。我们先来看看纹理坐标是怎么定义的。我们的图片都是二维的，平面是没有厚度的，所以平面也是二维的。所以纹理坐标是一个二维的坐标（X,Y）。每一个顶点都会有一个纹理坐标，就是用来表示这张图片应该是怎么贴到平面上的。如下图：

<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606ffcb096dee47a120785c9mtLAx2Ol03"></div>


##
##
## 相机
相机在场景中的作用是观察，你可以把它想象成你的眼睛。我们观察场景中的一切，都是依靠相机。相机又分有正交相机和透视相机。

#### 正交相机
这一摄像机使用orthographic projection（正交投影）来进行投影。在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。
这对于渲染2D场景或者UI元素是非常有用的。
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606fff6c7f9d2a147294b907qkRbPTrY03"></div>
图中,left, right, top, bottom, near, far,这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这两个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。其中,照相机的横竖比例确定，(right – left)与(top – bottom)的比例与视景体宽度与高度的比例一致。near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。


#### 透视相机
使用透视相机获取的景物类似人眼中的真实世界,有“近大远小”的效果。
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/606fffd596dee49479744b66hjBc2V1J03"></div>
在这张透视照相机投影图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角，如侧视图所示。照相机水平方向和竖直方向长度的比值（width / height），通常设为视景体的横纵比例。near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。

##
##
## 灯光
每个场景中至少会有一个光源，如果一个光源都没有，那就是一片漆黑。因为不同的3D引擎会提供的光源选择也不同，下面是以Unity 3D为例。
#### 方向光源
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/6070009aa7f252752f49a0a2uFyQ92dt03"></div>

*  这种类型的灯光可以被放置在无穷远处，可以影响场景中的一切游戏对象，类似于自然界中太阳光的照明效果。
*  定向光没有真正的光源坐标，放置在场景任何地点都不会影响光的效果，只有旋转会影响定向光的照射结果
#### 点光源
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/607002542786fd47a4862b007HDuvtoS03"></div>

*  点光源从一个位置向四面八方发出光线，影响其范围（Range）内的所有对象，类似灯泡的照明效果。
*  点光源的阴影是较耗费图像处理器资源的光源类型。
*  点光源的亮度从中心最强一直到范围属性(Range)设定的距离递减到0为止，光的强度从光源到距离成反比，这是所谓的”平方反比 定律”，类似光在现实世界的行为。

#### 聚光灯
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/607002e55e60274f8e7f6c656cELpLWp03"></div>
这种灯光从一点发出，在一个方向按照—个锥形的范围照射，该锥形是由聚光灯角度 (Spot Angle) 和范围 (Range) 界定的。 聚光灯是较耗费图形处理器资源的光源类型。 聚光灯投射一个锥体在他的Z轴前方，这个锥体的宽度由投射角度(Spot Angle)属性控制着，光线会从源头到设定的范围慢慢衰减到0，同时越靠近锥体边缘也会衰减，把投射角度的 值加大会让锥体宽度加大，同时也让边缘淡化的力度变大，这现象学名叫做”半影”。

聚光灯有许多用途，他们可以用来模拟路灯,壁灯,或许多创意用法，例如模拟手电筒，因为投射区域能精确的控制，因此很适合用来模拟打在角色身上的光或是模拟舞台灯光效果等等。

#### 区域光、面光源
<div align = "center"><img src="http://cc.fp.ps.netease.com/file/607003a58b74274e7abc5377iD7hfOwa03"></div>
该类型的光源无法应用于实时光照，仅适用于光照贴图烘焙 (lightmap baking)，这种光能从各方向照射一个平面的矩形截面的一侧。区域光可以当作是摄影用的柔光灯，在Unity里面他们被定义为单面往Z轴发射光线的矩形，目前只能和烘焙GI一起使用，区域光会均匀的照亮作用区域，虽然区域光没有范围属性可以调整，但是光的强度也是会随着距离光源越远而递减。


##
##
## 图形渲染管线
图形渲染管线（Graphics Pipeline）大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。

*  第一部分把你的3D坐标转换为2D坐标。
*  第二部分是把2D坐标转变为实际的有颜色的像素。

另外，2D坐标和像素也是不同的概念，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。

#### 数据处理的过程：
*  管线接受一组 3D 坐标，然后把它们转变为你屏幕上的有色 2D 像素输出。
*  管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。
*  所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。
*	由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据，这些小程序叫做着色器(Shader)。
    * 着色器有好几种，其中有些着色器允许开发者自己配置，以更细致地控制管线中的特定部分。
    * 着色器运行在GPU上。
    * OpenGL 着色器是用 OpenGL 着色器语言 (OpenGL Shading Language 即 GLSL) 写成的。

<div align = "center"><img src="http://cc.fp.ps.netease.com/file/607008526f04942e541445c87Mhie0iE03"></div>

1. 首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，这个数组叫做**顶点数据(Vertex Data)，是一系列顶点的集合**。
2. **顶点着色器(Vertex Shader)** 把顶点的3D坐标转为另一种3D坐标，同时允许我们对顶点属性进行一些基本处理。
3. **图元装配(Primitive Assembly)** 将所有的点装配成指定图元的形状。
4. **几何着色器(Geometry Shader)**  它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状，在我们这里，它生成了另一个三角形。
5. **光栅化阶段(Rasterization Stage)** 会把图元映射为最终屏幕上相应的像素，生成片段(Fragment)，并执行裁切(Clipping)，丢弃超出你的视图以外的所有像素提升效率。
6. **片段着色器(Fragment Shader)** 计算一个像素的最终颜色。
7. **Alpha测试和混合(Blending)** 阶段检测片段的对应的深度（和模板(Stencil)）值，决定是否丢弃；这个阶段也会检查alpha值并对物体进行混合(Blend)。